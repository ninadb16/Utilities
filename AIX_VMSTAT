import sys
import os
import threading
import traceback
import datetime
import time

from PyQt5.QtWidgets import (
    QApplication, QWidget, QLabel, QLineEdit, QPushButton, QVBoxLayout, QHBoxLayout,
    QFileDialog, QTextEdit, QProgressBar, QMessageBox, QFormLayout, QSpinBox, QCheckBox
)
from PyQt5.QtCore import Qt, pyqtSignal, QObject

import paramiko
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import numpy as np

# --- Backend Logic (Refactored for GUI) ---

def parse_config_file(file_path):
    config = {}
    with open(file_path, 'r') as f:
        for line in f:
            if '=' in line:
                key, value = line.strip().split('=', 1)
                config[key.strip()] = value.strip()
    return config

def collect_vmstat_data(config, log_callback, progress_callback, stop_event):
    """
    Collects vmstat data from remote AIX server.
    log_callback: function to send log/status messages to GUI.
    progress_callback: function to update progress bar.
    stop_event: threading.Event to signal stop.
    Returns: log_filename or raises Exception.
    """
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        log_callback("Connecting to host...")
        ssh.connect(
            config['host'],
            port=int(config['port']),
            username=config['username'],
            password=config['password'],
            timeout=10
        )
        log_callback("Connected. Starting monitoring...")
        start_time = datetime.datetime.now()
        end_time = start_time + datetime.timedelta(minutes=int(config['duration']))
        log_filename = f"vmstat_{start_time.strftime('%Y%m%d%H%M')}_{end_time.strftime('%Y%m%d%H%M')}.log"
        total_seconds = int(config['duration']) * 60
        interval = int(config['interval'])
        elapsed = 0
        with open(log_filename, 'w') as log_file:
            while datetime.datetime.now() < end_time:
                if stop_event.is_set():
                    log_callback("Monitoring stopped by user.")
                    break
                timestamp = datetime.datetime.now().isoformat()
                try:
                    stdin, stdout, stderr = ssh.exec_command(
                        "echo \"$(vmstat 1 2 | tail -1) $(vmstat -v | grep 'computational' | awk '{print $1}')\""
                    )
                    output = stdout.read().decode().strip()
                    if not output:
                        raise Exception(stderr.read().decode().strip())
                    log_file.write(f"{timestamp} {output}\n")
                    log_file.flush()
                    log_callback(f"Logged: {timestamp}")
                except Exception as e:
                    log_callback(f"Error during vmstat: {e}")
                elapsed = (datetime.datetime.now() - start_time).total_seconds()
                progress = min(int((elapsed / total_seconds) * 100), 100)
                progress_callback(progress)
                time.sleep(interval)
        ssh.close()
        log_callback(f"Monitoring complete. Log saved to {log_filename}")
        return log_filename
    except Exception as e:
        ssh.close()
        raise e

def parse_vmstat_log(log_filename):
    timestamps = []
    cpu_usages = []
    mem_usages = []
    with open(log_filename, 'r') as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) < 18:
                continue
            timestamp = parts[0]
            try:
                us = int(parts[14])
                sy = int(parts[15])
                idl = int(parts[16])
                avm = int(parts[3])
                fre = int(parts[4])
                cpu_usage = 100 - idl
                mem_usage = float(parts[20])
                timestamps.append(datetime.datetime.fromisoformat(timestamp))
                cpu_usages.append(cpu_usage)
                mem_usages.append(mem_usage)
            except Exception:
                continue
    return timestamps, cpu_usages, mem_usages

def downsample_data(timestamps, values, max_points=100):
    if len(timestamps) <= max_points:
        return timestamps, values
    step = len(timestamps) // max_points
    return timestamps[::step], values[::step]

def plot_usage(timestamps, series, name):
    timestamps, series = downsample_data(timestamps, series)
    plt.style.use('fivethirtyeight')
    plt.figure(figsize=(24, 12))
    plt.plot(timestamps, series, label=f'{name} Usage (%)')
    plt.xlabel('Time')
    plt.ylabel('Usage (%)')
    plt.title(f"{name} Usage Over Time")
    plt.ylim(0, 100)
    plt.yticks(range(0, 101, 10))
    if len(timestamps) > 12:
        positions = np.linspace(0, len(timestamps)-1, 13, dtype=int)
        plt.xticks([timestamps[i] for i in positions], rotation=45)
    plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%d-%m %H:%M:%S'))
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    filename = f"{name}_Usage_{datetime.datetime.now().strftime('%Y%m%d%H%M')}.png"
    plt.savefig(filename)
    plt.close()
    return filename

# --- PyQt5 GUI ---

class WorkerSignals(QObject):
    log = pyqtSignal(str)
    progress = pyqtSignal(int)
    finished = pyqtSignal(str)
    error = pyqtSignal(str)

class MonitorWorker(threading.Thread):
    def __init__(self, config, signals, stop_event):
        super().__init__()
        self.config = config
        self.signals = signals
        self.stop_event = stop_event

    def run(self):
        try:
            log_filename = collect_vmstat_data(
                self.config,
                self.signals.log.emit,
                self.signals.progress.emit,
                self.stop_event
            )
            self.signals.finished.emit(log_filename)
        except Exception as e:
            tb = traceback.format_exc()
            self.signals.error.emit(f"Error: {e}\n{tb}")

class AIXMonitorApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("AIX Monitor GUI")
        self.setMinimumWidth(600)
        self.monitor_thread = None
        self.stop_event = threading.Event()
        self.log_filename = None
        # --- UI Elements ---
        self.host_input = QLineEdit()
        self.host_input.setPlaceholderText("e.g., 192.168.1.10")
        self.host_input.setToolTip("Hostname or IP of AIX server")

        self.port_input = QSpinBox()
        self.port_input.setRange(1, 65535)
        self.port_input.setValue(22)
        self.port_input.setToolTip("SSH port (default 22)")

        self.username_input = QLineEdit()
        self.username_input.setPlaceholderText("e.g., root")
        self.username_input.setToolTip("SSH username")

        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.password_input.setToolTip("SSH password (will not be logged)")

        self.duration_input = QSpinBox()
        self.duration_input.setRange(1, 99999)
        self.duration_input.setValue(1)
        self.duration_input.setToolTip("Monitoring duration (minutes)")

        self.interval_input = QSpinBox()
        self.interval_input.setRange(1, 3600)
        self.interval_input.setValue(10)
        self.interval_input.setToolTip("Interval between samples (seconds)")

        self.config_file_input = QLineEdit()
        self.config_file_input.setReadOnly(True)
        self.config_file_input.setToolTip("Optional: Load config from file")

        self.browse_btn = QPushButton("Browse")
        self.browse_btn.setToolTip("Select config file")
        self.browse_btn.clicked.connect(self.browse_config_file)
        
        self.load_config_btn = QPushButton("Load from Config File")
        self.load_config_btn.setToolTip("Load config and populate fields (editable)")
        self.load_config_btn.clicked.connect(self.load_config_file_editable)


        self.use_config_checkbox = QCheckBox("Use config file")
        self.use_config_checkbox.setToolTip("Enable to load parameters from config file")
        self.use_config_checkbox.stateChanged.connect(self.toggle_config_file)

        # Buttons
        self.start_btn = QPushButton("Start Monitoring")
        self.start_btn.clicked.connect(self.start_monitoring)
        self.start_btn.setToolTip("Start monitoring the AIX server")
        self.start_btn.setStyleSheet("background-color : green; color: white")

        self.stop_btn = QPushButton("Stop")
        self.stop_btn.clicked.connect(self.stop_monitoring)
        self.stop_btn.setEnabled(False)
        self.stop_btn.setToolTip("Stop monitoring")

        self.plot_cpu_btn = QPushButton("Plot CPU Usage")
        self.plot_cpu_btn.clicked.connect(lambda: self.plot_usage('CPU'))
        self.plot_cpu_btn.setEnabled(False)
        self.plot_cpu_btn.setToolTip("Plot CPU usage graph")

        self.plot_mem_btn = QPushButton("Plot Memory Usage")
        self.plot_mem_btn.clicked.connect(lambda: self.plot_usage('Memory'))
        self.plot_mem_btn.setEnabled(False)
        self.plot_mem_btn.setToolTip("Plot Memory usage graph")

        self.view_log_btn = QPushButton("View Log")
        self.view_log_btn.clicked.connect(self.view_log)
        self.view_log_btn.setEnabled(False)
        self.view_log_btn.setToolTip("Open the log file")

        # Status/Log area
        self.log_area = QTextEdit()
        self.log_area.setReadOnly(True)
        self.log_area.setMinimumHeight(120)

        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setValue(0)
        self.load_log_btn = QPushButton("Load Log File")
        self.load_log_btn.setToolTip("Load a previously saved vmstat log file")


        # --- Layout ---
        form_layout = QFormLayout()
        form_layout.addRow("Host:", self.host_input)
        form_layout.addRow("Port:", self.port_input)
        form_layout.addRow("Username:", self.username_input)
        form_layout.addRow("Password:", self.password_input)
        form_layout.addRow("Duration (min):", self.duration_input)
        form_layout.addRow("Interval (sec):", self.interval_input)

        config_layout = QHBoxLayout()
        config_layout.addWidget(self.config_file_input)
        config_layout.addWidget(self.browse_btn)
        config_layout.addWidget(self.load_config_btn)
        form_layout.addRow(self.use_config_checkbox, config_layout)

        btn_layout = QHBoxLayout()
        btn_layout.addWidget(self.start_btn)
        btn_layout.addWidget(self.stop_btn)
        btn_layout.addWidget(self.plot_cpu_btn)
        btn_layout.addWidget(self.plot_mem_btn)
        btn_layout.addWidget(self.view_log_btn)

        main_layout = QVBoxLayout()
        main_layout.addLayout(form_layout)
        main_layout.addWidget(self.progress_bar)
        main_layout.addLayout(btn_layout)
        main_layout.addWidget(QLabel("Status / Log:"))
        main_layout.addWidget(self.log_area)
        self.load_log_btn = QPushButton("Load Log File")
        self.load_log_btn.setToolTip("Load a previously saved vmstat log file")
        self.load_log_btn.clicked.connect(self.load_log_file)
        btn_layout.addWidget(self.load_log_btn)


        self.setLayout(main_layout)

    
    def load_config_file_editable(self):
        fname, _ = QFileDialog.getOpenFileName(self, "Select Config File", "", "Config Files (*.conf *.txt);;All Files (*)")
        if fname:
            self.config_file_input.setText(fname)
            try:
                config = parse_config_file(fname)
                self.set_fields_from_config(config, editable=True)
            except Exception as e:
                self.show_error(f"Failed to load config: {e}")


    # --- UI Actions ---

    def browse_config_file(self):
        fname, _ = QFileDialog.getOpenFileName(self, "Select Config File", "", "Config Files (*.conf *.txt);;All Files (*)")
        if fname:
            self.config_file_input.setText(fname)

    
    def toggle_config_file(self, state):
        enabled = state == Qt.Checked
        self.config_file_input.setEnabled(enabled)
        self.browse_btn.setEnabled(enabled)
        self.load_config_btn.setEnabled(not enabled)  # Disable load button if using config
        if enabled:
            # Load config and gray out fields
            config_file = self.config_file_input.text()
            if config_file and os.path.isfile(config_file):
                try:
                    config = parse_config_file(config_file)
                    self.set_fields_from_config(config, editable=False)
                except Exception as e:
                    self.show_error(f"Failed to load config: {e}")
            for widget in [self.host_input, self.port_input, self.username_input, self.password_input, self.duration_input, self.interval_input]:
                widget.setEnabled(False)
        else:
            # Make fields editable again
            for widget in [self.host_input, self.port_input, self.username_input, self.password_input, self.duration_input, self.interval_input]:
                widget.setEnabled(True)

    
    def set_fields_from_config(self, config, editable):
        self.host_input.setText(config.get('host', ''))
        self.port_input.setValue(int(config.get('port', 22)))
        self.username_input.setText(config.get('username', ''))
        self.password_input.setText(config.get('password', ''))
        self.duration_input.setMaximum(999999)
        self.duration_input.setValue(int(config.get('duration', 1)))
        self.interval_input.setValue(int(config.get('interval', 10)))
        for widget in [self.host_input, self.port_input, self.username_input, self.password_input, self.duration_input, self.interval_input]:
            widget.setEnabled(editable)


    def start_monitoring(self):
        # Validate inputs
        try:
            if self.use_config_checkbox.isChecked():
                config_file = self.config_file_input.text()
                if not config_file or not os.path.isfile(config_file):
                    self.show_error("Please select a valid config file.")
                    return
                config = parse_config_file(config_file)
                for key in ['host', 'port', 'username', 'password', 'duration', 'interval']:
                    if key not in config:
                        self.show_error(f"Missing '{key}' in config file.")
                        return
            else:
                config = {
                    'host': self.host_input.text().strip(),
                    'port': self.port_input.value(),
                    'username': self.username_input.text().strip(),
                    'password': self.password_input.text(),
                    'duration': self.duration_input.value(),
                    'interval': self.interval_input.value()
                }
                for key, val in config.items():
                    if not val and key != 'port':
                        self.show_error(f"Please enter {key}.")
                        return
            # Security: sanitize inputs
            if not config['host'] or not config['username'] or not config['password']:
                self.show_error("Host, username, and password are required.")
                return
            if not (1 <= int(config['port']) <= 65535):
                self.show_error("Port must be between 1 and 65535.")
                return
            if int(config['duration']) < 1 or int(config['interval']) < 1:
                self.show_error("Duration and interval must be positive integers.")
                return
        except Exception as e:
            self.show_error(f"Input error: {e}")
            return

        # Confirmation dialog for overwriting log
        self.log_filename = None
        self.progress_bar.setValue(0)
        self.log_area.clear()
        self.append_log("Starting monitoring...")
        self.start_btn.setEnabled(False)
        self.stop_btn.setEnabled(True)
        self.stop_btn.setStyleSheet("background-color : red; color: white")
        self.plot_cpu_btn.setEnabled(False)
        self.plot_mem_btn.setEnabled(False)
        self.view_log_btn.setEnabled(False)
        self.stop_event.clear()

        # Threaded monitoring
        self.signals = WorkerSignals()
        self.signals.log.connect(self.append_log)
        self.signals.progress.connect(self.progress_bar.setValue)
        self.signals.finished.connect(self.monitoring_finished)
        self.signals.error.connect(self.show_error)

        self.monitor_thread = MonitorWorker(config, self.signals, self.stop_event)
        self.monitor_thread.start()

    def stop_monitoring(self):
        if self.monitor_thread and self.monitor_thread.is_alive():
            reply = QMessageBox.question(self, "Stop Monitoring", "Are you sure you want to stop monitoring?",
                                         QMessageBox.Yes | QMessageBox.No)
            if reply == QMessageBox.Yes:
                self.stop_event.set()
                self.append_log("Stopping monitoring...")

    def monitoring_finished(self, log_filename):
        self.log_filename = log_filename
        self.append_log(f"Monitoring complete. Log saved to {log_filename}")
        self.start_btn.setEnabled(True)
        self.stop_btn.setEnabled(False)
        self.stop_btn.setStyleSheet("background-color : white; color: black")
        self.plot_cpu_btn.setEnabled(True)
        self.plot_mem_btn.setEnabled(True)
        self.view_log_btn.setEnabled(True)
        self.progress_bar.setValue(100)

    def plot_usage(self, usage_type):
        # Use loaded log if present, else use monitored log
        log_file = getattr(self, 'loaded_log_filename', None) or self.log_filename
        if not log_file or not os.path.isfile(log_file):
            self.show_error("No valid log file found. Please run monitoring or load a log file.")
            return
        try:
            timestamps, cpu_usages, mem_usages = parse_vmstat_log(log_file)
            if not timestamps:
                self.show_error("Log file is empty or invalid.")
                return
            if usage_type == 'CPU':
                filename = plot_usage(timestamps, cpu_usages, "CPU")
            else:
                filename = plot_usage(timestamps, mem_usages, "Memory")
            self.append_log(f"{usage_type} usage plot saved to {filename}")
            if os.name == 'nt':
                os.startfile(filename)
            else:
                import subprocess
                subprocess.Popen(['xdg-open', filename])
        except Exception as e:
            self.show_error(f"Plotting error: {e}")


    def view_log(self):
        if self.log_filename and os.path.isfile(self.log_filename):
            try:
                if os.name == 'nt':
                    os.startfile(self.log_filename)
                else:
                    import subprocess
                    subprocess.Popen(['xdg-open', self.log_filename])
            except Exception as e:
                self.show_error(f"Could not open log file: {e}")
        else:
            self.show_error("No log file found.")

    def append_log(self, message):
        self.log_area.append(f"[{datetime.datetime.now().strftime('%H:%M:%S')}] {message}")

    def show_error(self, message):
        self.append_log(f"ERROR: {message}")
        QMessageBox.critical(self, "Error", message)
        self.start_btn.setEnabled(True)
        self.stop_btn.setEnabled(False)
        self.plot_cpu_btn.setEnabled(bool(self.log_filename))
        self.plot_mem_btn.setEnabled(bool(self.log_filename))
        self.view_log_btn.setEnabled(bool(self.log_filename))
        self.progress_bar.setValue(0)
    
    def load_log_file(self):
        fname, _ = QFileDialog.getOpenFileName(self, "Select Log File", "", "Log Files (*.log *.txt);;All Files (*)")
        if fname and os.path.isfile(fname):
            try:
                timestamps, cpu_usages, mem_usages = parse_vmstat_log(fname)
                if not timestamps or not cpu_usages or not mem_usages:
                    self.show_error("Selected log file is empty or invalid.")
                    return
                self.loaded_log_filename = fname  # Store separately from monitored log
                self.append_log(f"Loaded log file: {fname}")
                self.plot_cpu_btn.setEnabled(True)
                self.plot_mem_btn.setEnabled(True)
                # Do NOT enable view_log_btn for loaded logs
                self.progress_bar.setValue(100)
            except Exception as e:
                self.show_error(f"Failed to load log file: {e}")


# --- Main ---

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = AIXMonitorApp()
    window.show()
    sys.exit(app.exec_())
